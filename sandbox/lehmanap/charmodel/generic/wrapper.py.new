import pdb
from zope.interface import interface, implements
from twisted.python import components
import types
tabbies = ""

class ICondition( interface.Interface ):
	"""
	Represents a logical condition.
	"""
	original=interface.Method("original", """The function representing the test condition.  Should take a context object.""")
	
	def andCondition( condition ):
		"""
		Returns an ICondition that is equivalent to 'self and condition'
		"""
		pass

	def orCondition( condition ):
		"""
		Returns an ICondition that is equivalent to 'self or condition'
		"""
		pass

	def notCondition( ):
		"""
		Returns an ICondition that is equivalent to 'not self'
		"""
		pass

	def __call__( context ):
		"""
		Tests the condition with the given context
		"""
		pass

class IConditioned( interface.Interface ):
	"""
	Something that has a Condition.
	"""
	condition=interface.Attribute("condition", """The condition""")
	_doStuff=interface.Method("_doStuff", """This method is the actual action that happens if the condition passes.""")

	def __call__( context ):
		"""
		Check the condition, and if it passes, do the stuff.
		"""
		pass

class IObserver( interface.Interface ):
	"""
	A wrapper to indicate the object is an observer.
	"""

	name=interface.Attribute("name", """The name of this observer function""")
	original=interface.Method("original", """The original function""")
	condition=interface.Attribute("condition", 
		"""The condition that must be met after the observed function fires for this function to fire.""")

	def observed( self, observed, *args, **kwargs ):
		"""
		This should be called when the observed function has been called.
		"""
		pass

class IObserved( interface.Interface ):
	"""
	A wrapper around a function that allows other functions to observe it, and
	take action upon its calling.
	"""

	name=interface.Attribute("name", """The name of this observed function""")
	original=interface.Method("original", """The original function""")
	condition=interface.Attribute("condition", 
		"""The condition that must before the observers will be notified.""")

	def observe( self, *args, **kwargs ):
		"""
		This should call any observers that are registered.
		"""
		pass

	def add( self, observer ):
		"""
		This should pass searches for attributes down to the observed method,
		as an IObserver should be transparent.
		"""
		pass

class Condition( object ):
	"""
	Represents a logical condition.

	Set up a couple simple Conditions.
	>>> values = [1]
	>>> odd = Condition(lambda *args, **kwargs: values[0] % 2 != 0)
	>>> even = Condition(lambda *args, **kwargs: values[0] % 2 == 0)

	Odd is odd, and Even is even.
	>>> values[0] = 1
	>>> odd(None)
	True
	>>> values[0]=0
	>>> odd(None)
	False
	>>> values[0] = 1
	>>> even(None)
	False
	>>> values[0]=0
	>>> even(None)
	True

	We can modify the conditions after they are set up via andCondition, orCondition, and notCondition methods.
	First, lets save the old ones, so we can reset for each test.
	>>> oldconditions = (even, odd)

	Notted odd is the same as even.
	>>> even, odd = oldconditions
	>>> odd = odd.notCondition( )
	>>> values[0] = 1
	>>> odd(None)
	False
	>>> values[0] = 0
	>>> odd(None)
	True

	Now odd is true if its odd, or divisible by 8.
	>>> even, odd = oldconditions
	>>> odd = odd.orCondition( lambda context: values[0] % 8 == 0 )
	>>> values[0] = 1
	>>> odd(None)
	True
	>>> values[0] = 8
	>>> odd(None)
	True

	But not otherwise.
	>>> values[0] = 2
	>>> odd(None)
	False

	Now odd is true if it is odd AND negative.
	>>> even, odd = oldconditions
	>>> odd = odd.andCondition( lambda context: values[0] < 0 )
	>>> values[0] = -1
	>>> odd(None)
	True

	But not if just one, or neither, is true
	>>> values[0] = 1
	>>> odd(None)
	False
	>>> values[0] = -2
	>>> odd(None)
	False
	>>> values[0] = 2
	>>> odd(None)
	False

	Wild and crazy types might even mix and match.  Now the value cannot be both odd and negative.
	>>> even, odd = oldconditions
	>>> odd = odd.andCondition( lambda context: values[0] < 0 ).notCondition( )
	>>> values[0] = -1
	>>> odd(None)
	False

	Either one will work, however
	>>> values[0] = 1
	>>> odd(None)
	True
	>>> values[0] =-2
	>>> odd(None)
	True

	"""
	implements( ICondition )
	
	def __init__( self, original=True ):
		if callable(original):
			self.original=original
		else:
			self.original=lambda context: True
	
	def andCondition( self, condition ):
		"""
		Returns an ICondition that is equivalent to 'self and condition'
		"""
		condition=ICondition( condition )
		return Condition( lambda context: self( context ) and condition( context ) )

	def orCondition( self, condition ):
		"""
		Returns an ICondition that is equivalent to 'self or condition'
		"""
		condition=ICondition( condition )
		return Condition( lambda context: self( context ) or condition( context ) )

	def notCondition( self ):
		"""
		Returns an ICondition that is equivalent to 'not self'
		"""
		return Condition( lambda context: not self( context ) )

	def __call__( self, context ):
		"""
		Tests the condition with the given context
		"""
		return self.original( context )

components.registerAdapter(
	Condition,
	types.FunctionType,
	ICondition)

components.registerAdapter(
	Condition,
	types.ObjectType,
	ICondition)

class MyObject( object ):
    def __str__( self ):
        return "%s.%s" % ( self.__class__.__module__, self.__class__.__name__ )

    def __repr__( self ):
        return "%s %s" % ( str( self ), super( MyObject, self ).__repr__( ) )

class Conditioned( MyObject ):
	implements( IConditioned )

	def __init__(self, condition, doStuff):
		self.condition=ICondition(condition)
		self._doStuff=doStuff

	def __call__( self, *args, **kwargs ):
		if self.condition(None):#We need to have a context, instead of None, to get the big picture
			return self._doStuff( *args, **kwargs )

class ObserverFunction( Conditioned ):
	implements( IObserver )

	def _getName( self ):
		return self.original.func_name

	def _setName( self, value ):
		self.original.func_name=value

	name=property(fget=_getName, fset=_setName, doc="""Name of the observer function.""")

	def __init__( self, original, condition=None ):
		super( ObserverFunction, self ).__init__( condition, self.observed )
		self.original = original

	def observed( self, observed, *args, **kwargs ):
		observed = IObserved( observed )
		self.original( observed, *args, **kwargs )

components.registerAdapter(
	ObserverFunction,
	types.FunctionType,
	IObserver)

class ObservedFunction( Conditioned ):
	"""
	A wrapper around a function that allows for other functions to be called
	upon the call of said function.

	First, create the function to observe and the one to be observed.
	>>> def observedFunc(x):
	...  return x + 5
	>>> def observerFunc1(target, *args, **kwargs):
	...  print "'observerFunc1' observed '%s' with args=%s and kwargs=%s" % (IObserved(target).name, args, kwargs)
	>>> def observerFunc2(target, *args, **kwargs):
	...  print "'observerFunc2' observed '%s' with args=%s and kwargs=%s" % (IObserved(target).name, args, kwargs)

	Then, wrap the observed function, and add the abserver to it.
	>>> observed=ObservedFunction(observedFunc)
	>>> observed.add(observerFunc1)

	Now call the observed function as normal.
	>>> observed(5)
	'observerFunc1' observed 'observedFunc' with args=(5,) and kwargs={}
	10

	We can also put conditions on things.
	>>> values = [1]
	>>> observedCondition = lambda context: values[0] % 2 == 0
	>>> observerCondition1 = lambda context: values[0] % 3 == 0
	>>> observerCondition2 = lambda context: values[0] % 5 == 0
	>>> observed = ObservedFunction(observedFunc, observedCondition)
	>>> observer1 = ObserverFunction(observerFunc1, observerCondition1)
	>>> observer2 = ObserverFunction(observerFunc2, observerCondition2)
	>>> observed.add( observer1 )
	>>> observed.add( observer2 )

	Now there are conditions on both the observer and the observed
	Since 1 is not divisible by 2, we expect no output, as the observed function will not fire events to its observers.
	>>> values[0]=1
	>>> observed(5)

	Since 6 is divisible by 2 and 3, but not 5, we expect output from the observed and from observer1, but not observer2
	>>> values[0]=6
	>>> observed(5)
	'observerFunc1' observed 'observedFunc' with args=(5,) and kwargs={}
	10

	Since 10 is divisible by 2 and 5, but not 3, we expect output from the observed from observer2, but not observer1
	>>> values[0]=10
	>>> observed(5)
	'observerFunc2' observed 'observedFunc' with args=(5,) and kwargs={}
	10

	Since 30 is divisible by 2, 3 and 5, we expect output from all functions
	>>> values[0]=30
	>>> observed(5)
	'observerFunc1' observed 'observedFunc' with args=(5,) and kwargs={}
	'observerFunc2' observed 'observedFunc' with args=(5,) and kwargs={}
	10

	"""

	implements( IObserved )

	def _getName( self ):
		return self.original.func_name

	def _setName( self, value ):
		self.original.func_name=value

	name=property(fget=_getName, fset=_setName, doc="""Name of the observed function.""")

	def __init__( self, original, condition=None ):
		super( ObservedFunction, self ).__init__( condition, self.observe )
		self.original = original
		self.observers = [ ]
		self._doStuff = self.observe

	def observe( self, *args, **kwargs ):
		"""
		This should call any observers that are registered.
		"""
		for observer in self.observers:
			IObserver(observer)( self, *args, **kwargs )
		return self.original( *args, **kwargs )

	def add( self, observer ):
		"""
		Add the observer to the notify list.
		"""
		self.observers.append( observer )

components.registerAdapter(
	ObservedFunction,
	types.FunctionType,
	IObserved)

class ConditionalFunction( ObservedFunction ):
	"""
	Observed wrapper that calls one of two callables based on whether a
	condition tests true or not.

	First, set up the alternats and the conditional.
	>>> values = [1]
	>>> def yes(*args, **kwargs):
	...  return "Yes!"
	>>> def no(*args, **kwargs):
	...  return "No!"
	>>> def cond(*args, **kwargs):
	...  return values[0] % 2 == 0
	>>> conditional=ConditionalFunction(cond, yes, no)

	Since 1 is not divisible by 2, we expect the 'no' function to be called.
	>>> values[0]=1
	>>> conditional()
	'No!'

	Since 2 is divisible by 2, we expect the 'yes' function to be called
	>>> values[0]=2
	>>> conditional()
	'Yes!'

	"""
	def __init__( self, cond, method, altmethod=None, condition=None ):
		altmethod=altmethod or (lambda context, *args, **kwargs: 0)
		super( ConditionalFunction, self ).__init__(
			lambda context=None, *args, **kwargs:
				{True: method, False: altmethod}[ICondition(cond)(context)](context, *args, **kwargs)
		)

def _test():
	import doctest
	#doctest.testmod(verbose=True)
	doctest.testmod()

if __name__ == '__main__':
	_test()
